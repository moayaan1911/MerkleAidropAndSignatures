// SPDX-License-Identifier: MIT

pragma solidity ^0.8.24;

import {Test, console} from "forge-std/Test.sol";
import {MerkelAirdrop} from "src/MerkelAirdrop.sol";
import {BagelToken} from "src/BagelToken.sol";
import {DeployMerkelAirdrop} from "script/DeployMerkelAidrop.s.sol";

/**
 * @title MerkelAirdropTest
 * @author moayaan.eth
 * @notice Tests for Merkle airdrop claiming functionality
 * @dev Test values sourced from GenerateInput.s.sol, MakeMerkel.s.sol outputs:
 * - MERKLE_ROOT: from /script/target/output.json (generated by MakeMerkel.s.sol)
 * - MERKLE_PROOF: proof array elements from output.json
 * - AMOUNT_TO_CLAIM: 25 tokens (specified in GenerateInput.s.sol input.json)
 */
contract MerkelAirdropTest is Test {
    MerkelAirdrop public merkelAirdrop;
    BagelToken public bagelToken;

    // Merkle root from output.json (generated by MakeMerkel.s.sol script)
    bytes32 public constant MERKLE_ROOT = 0xaa5d581231e596618465a56aa0f5870ba6e20785fe436d5bfb82b08662ccc7c4;

    // Individual proof elements from the Merkle proof array in output.json
    bytes32 proof1 = 0x0fd7c981d39bece61f7499702bf59b3114a90e66b51ba2c53abdf7b62986c00a;
    bytes32 proof2 = 0xe5ebd1e1b5a5478a944ecab36a9a954ac3b6b8216875f6524caa7a1d87096576;

    // Complete Merkle proof array needed for claiming (from output.json)
    bytes32[] public MERKLE_PROOF = [proof1, proof2];

    // Amount per user from input.json: 25 tokens with 18 decimals
    uint256 public constant AMOUNT_TO_CLAIM = 25 * 1e18;

    // Total amount to mint: 25 tokens Ã— 4 whitelist addresses
    uint256 public constant AMOUNT_TO_MINT = AMOUNT_TO_CLAIM * 4;

    // Test user address and private key
    address user;
    uint256 userPrivateKey;

    address gasPayer;

    /**
     * @dev Setup function runs before each test
     * @notice Uses DeployMerkelAirdrop script to deploy contracts (same as production)
     */
    function setUp() public {
        // Create instance of DeployMerkelAirdrop script
        DeployMerkelAirdrop deployMerkelAirdrop = new DeployMerkelAirdrop();
        // Deploy both MerkelAirdrop and BagelToken contracts via script
        (merkelAirdrop, bagelToken) = deployMerkelAirdrop.deployMerkelAirdrop();
        // Create test user with address and private key
        (user, userPrivateKey) = makeAddrAndKey("user");
        gasPayer = makeAddr("gasPayer");
    }

    /**
     * @notice Test that a whitelisted user can successfully claim their airdrop
     * @dev Uses Merkle proof from output.json to verify the claim is valid
     */
    function testUserCanClaim() public {
        // Get user's starting balance (should be 0)
        uint256 startingBalance = bagelToken.balanceOf(user);
        console.log("Starting Balance of the user is: ", startingBalance);

        // Get the EIP-712 typed data digest that needs to be signed for the claim
        bytes32 digest = merkelAirdrop.getMessageHash(user, AMOUNT_TO_CLAIM);

        // Sign the digest with user's private key to generate ECDSA signature (v, r, s)
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, digest);

        // Call claim function from gasPayer address (gasPayer pays transaction fees)
        // This simulates a relayer or third party paying gas for the user's claim
        vm.prank(gasPayer);

        // Execute the claim: verifies signature, Merkle proof, transfers tokens, and marks as claimed
        merkelAirdrop.claim(user, AMOUNT_TO_CLAIM, MERKLE_PROOF, v, r, s);

        // Get user's balance after claim
        uint256 endingBalance = bagelToken.balanceOf(user);
        console.log("Ending Balance of the user is: ", endingBalance);

        // Verify user received exactly AMOUNT_TO_CLAIM tokens
        assertEq(endingBalance - startingBalance, AMOUNT_TO_CLAIM);
    }
}
